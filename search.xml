<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[记一次 .class 文件的修改]]></title>
      <url>%2F2017%2F03%2F31%2Fmodify-java-class-file%2F</url>
      <content type="text"><![CDATA[参考资料 直接修改别人jar包里面的class文件 工具:jclasslib 背景交代因为 Android Studio 中的 Android Icon Creator 插件生成的图片路径还是在 drawable 之下，和同事纠结了一下还是决定将所有图片放在 mipmap 下面，所以就产生了动插件 jar 包的想法。 ROUND 1 - BytecodeViewer 2.9.8很方便很强大的一个工具 在 Plugins 选项中，可以查看所有 String 和 修改 String 的功能。 但是在看 loading view 转啊转，重新打开文件的时候，并没有修改成功，卒 ROUND 2 - javac, javap我们都知道，源文件 .java 通过 javac 变成字节码文件 .class, 那。。有没有一个命令是可以直接恢复 .class 文件变成 .java 文件呢？(呵呵，想得美 么，然后就找到了 javap javap 可以查看 .class 文件的结构信息 就像这样 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273C:\Users\HCol\Desktop&gt;javap HelloWorld.classCompiled from &quot;HelloWorld.java&quot;public class HelloWorld &#123; public HelloWorld(); public static final void main(java.lang.String[]);&#125;C:\Users\HCol\Desktop&gt;javap -v HelloWorld.classClassfile /C:/Users/HCol/Desktop/HelloWorld.class Last modified 2017-3-31; size 427 bytes MD5 checksum a185526841e54eac7ed70bfe00bc6840 Compiled from &quot;HelloWorld.java&quot;public class HelloWorld minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #6.#15 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V #2 = Fieldref #16.#17 // java/lang/System.out:Ljava/io/PrintStream; #3 = String #18 // Hello, world! #4 = Methodref #19.#20 // java/io/PrintStream.println:(Ljava/lang/String;)V #5 = Class #21 // HelloWorld #6 = Class #22 // java/lang/Object #7 = Utf8 &lt;init&gt; #8 = Utf8 ()V #9 = Utf8 Code #10 = Utf8 LineNumberTable #11 = Utf8 main #12 = Utf8 ([Ljava/lang/String;)V #13 = Utf8 SourceFile #14 = Utf8 HelloWorld.java #15 = NameAndType #7:#8 // &quot;&lt;init&gt;&quot;:()V #16 = Class #23 // java/lang/System #17 = NameAndType #24:#25 // out:Ljava/io/PrintStream; #18 = Utf8 Hello, world! #19 = Class #26 // java/io/PrintStream #20 = NameAndType #27:#28 // println:(Ljava/lang/String;)V #21 = Utf8 HelloWorld #22 = Utf8 java/lang/Object #23 = Utf8 java/lang/System #24 = Utf8 out #25 = Utf8 Ljava/io/PrintStream; #26 = Utf8 java/io/PrintStream #27 = Utf8 println #28 = Utf8 (Ljava/lang/String;)V&#123; public HelloWorld(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return LineNumberTable: line 3: 0 public static final void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL Code: stack=2, locals=1, args_size=1 0: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #3 // String Hello, world! 5: invokevirtual #4 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: return LineNumberTable: line 6: 0 line 7: 8&#125;SourceFile: &quot;HelloWorld.java&quot;C:\Users\HCol\Desktop&gt; 好了，然而这波哔并不能装，就看看就好了，卒 ROUND 3 - jclasslib好，既然到这儿了，那么这次我们就一定能改成功了，事不过三嘛(笑死 找到我们想要修改的地方 这里我要修改的是 “Hello,world!”, 我们把它改成 “HAHAHA!” 因为 “Hello,world!” 是一个 String 而且是在 main 方法里面，所以我们只需要关注几个地方就好了: 常量池(Constant Pool) 方法名(Method#main) …. 去常量池找到目标资源 点击序号即可在常量池中定位到资源了，咦 String_info 好像是哦， 还可以点嘎， Utf8_info ，咦，完了… 嗯, 最后那个 Utf8_info 就是我们想要修改的目标资源了，记住序号 18 修改 123456789101112131415161718192021222324252627282930313233343536373839404142434445 String filePath = "G:/HelloWorld.class";String targetStr = "Hello, world!";String replaceStr = "HAHAHA!";int targetStrIndex = 18;FileInputStream fInput = null;DataInput di = null;try &#123; File mTargetFile = new File(filePath); fInput = new FileInputStream(mTargetFile.getAbsolutePath()); di = new DataInputStream(fInput); ClassFile cf = new ClassFile(); cf.read(di); CPInfo[] cps = cf.getConstantPool(); for (int i = 0; i &lt;= cps.length; i++) &#123; if (i == targetStrIndex) &#123; String mStr = cps[i].getVerbose(); System.out.println("before: " + mStr); StringBuilder sb = new StringBuilder(mStr); sb.replace(0, targetStr.length(), replaceStr); mStr = sb.toString(); System.out.println("after: " + mStr); ConstantUtf8Info mUtf8Info = (ConstantUtf8Info) cps[i]; mUtf8Info.setString(mStr); cps[i] = mUtf8Info; &#125; &#125; cf.setConstantPool(cps); fInput.close(); File f = new File(filePath); ClassFileWriter.writeToFile(f, cf);&#125; catch (Exception e) &#123; e.printStackTrace();&#125; 运行结果]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[初见SurafaceView 和 仿微信小游戏]]></title>
      <url>%2F2017%2F03%2F08%2Fsurface-view-and-game%2F</url>
      <content type="text"><![CDATA[What is SurfaceView官方文档 Provides a dedicated drawing surface embedded inside of a view hierarchy. You can control the format of this surface and, if you like, its size; the SurfaceView takes care of placing the surface at the correct location on the screen. – from offical doc 这是在视图层级，专注于绘画的一个视图组件。你可以控制嵌套在它内部的表视图(surface)的格式和大小； SurfaceView 主要负责更新和替换当前屏幕上的表视图(surface)。 从它直接子类: VideoView 的名字看来，不难想象 SurfaceView 为什么说它 dedicated drawing 。 这里我们可以简单理解为，当我们有一个界面需要不断刷新，频繁更新视图或子视图时，这时我们就可以使用 SurfaceView 了。( 像 Video 一样，一帧一帧的更新… Why SurfaceView摘抄自 《Android 群英传》： Android 系统提供了 View 进行绘图处理， View 可以满足大部分的绘图需求， 但在某些时候， 却也有些心有余而力不足，特别是在进行一些开发的时候。 我们知道， View 通过进行刷新来重绘视图， Android 系统通过发出 VSYNC 信号来进行屏幕的重绘， 刷新的间隔时间为 16ms。如果在 16ms 内 View 完成了你所需要执行的所有操作，那么用户在视觉上，就不会产生卡顿的感觉； 而如果执行的操作逻辑太多，特别是需要频繁刷新的界面上，例如游戏界面，那么就会不断阻塞主线程，从而导致画面卡顿。很多时候，在自定义 View 的 log 中经常会看见如下警告： 1“Skipped 47 frames！The application may be doing too much work on its main thread” 这些警告的产生，很多情况下就是因为在绘制过程中，处理逻辑太多造成的。 为了避免这一问题的产生， Android 系统提供了 SurfaceView 组件来解决这个问题。 SurfaceView 可以说是 View 的孪生兄弟， 但它与 View 还是有所不同的， 他们的区别主要体现在一下几点： View 主要适用于主动更新的情况下，而 SurfaceView 主要适用于被动更新，例如频繁地刷新。 View 在主线程中对画面进行刷新，而 SurfaceView 通常会通过一个子线程来进行页面的刷新。 View 在绘图时没有使用双缓冲机制，而 SurfaceView 在底层实现机制中就已经实现了双缓冲机制。 总结成一句话就是， 如果你的自定义 View 需要频繁刷新，或者刷新时数据处理量比较大，那么你就可以考虑用 SurfaceView 来取代 View 了。 Usage在只是用之前，强烈建议看下 《游戏编程》第一部 基础篇 #游戏动画原理 章节，方便理解 SurfaceView 的一些原理。 1234// SurfaceView 中那两个&quot;擦-画-换&quot;的主儿final Surface mSurface = new Surface(); // Current surface in usefinal Surface mNewSurface = new Surface(); // New surface we are switching to 我们接着来了解关于 SurfaceView 的一些操作我们会涉及到哪些类： SurfaceView ( 类 Frame 角色？ View 的直接子类，基础组件。 SurfaceHolder ( 类 Presenter/Controller 角色？ SurfaceView 的辅助类，用来操作 Surface 和跟踪 Surface 生命周期，是实现关键。 Surface ( 类 View 角色？ 基本屏蔽，“画”的动作也由 SurfaceHolder 代理了。 Thread ( JUST A FUCKING LOOPER.. loooooooooooooooper… 使用方法及重点方法说明123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114/** * Created by HCol on 2017/3/8. */public class SurfaceViewDemo extends SurfaceView implements Runnable &#123; //###########################################################################################// //####################################### Requirement #######################################// //###########################################################################################// private SurfaceHolder mSurfaceHolder; private Canvas mCanvas; private Thread mRefresher = new Thread(this); private Bitmap mBmp; private Paint mPaint = new Paint(Paint.ANTI_ALIAS_FLAG); private int x; private int y; private int speedY = 2; @Override public void run() &#123; while (true) &#123; // 这里需要注意的是，lockCanvas() 不一定能拿到 Canvas, 原因之一是 Surface 没创建好， // 之二就是 Surface 处于无法编辑状态。 mCanvas = mSurfaceHolder.lockCanvas(); // do refresh logic here drawSelf(mCanvas); mSurfaceHolder.unlockCanvasAndPost(mCanvas); try &#123; y -= speedY; Thread.sleep(16); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // Exit loop if (y + mBmp.getHeight() &lt; 0) &#123; break; &#125; &#125; &#125; private void drawSelf(Canvas canvas) &#123; if (canvas == null) &#123; return; &#125; canvas.drawColor(Color.WHITE); canvas.save(); canvas.drawBitmap(mBmp, x, y, mPaint); canvas.restore(); &#125; private SurfaceHolderCallbackImp callbackImp = new SurfaceHolderCallbackImp(); private class SurfaceHolderCallbackImp implements SurfaceHolder.Callback, SurfaceHolder.Callback2 &#123; @Override public void surfaceCreated(SurfaceHolder holder) &#123; // call once // some initialize code here mBmp = BitmapFactory.decodeResource(getResources(), R.drawable.boss_plane1); x = (getWidth() - mBmp.getWidth()) / 2; y = getHeight() - mBmp.getHeight() * 2; mRefresher.start(); &#125; @Override public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) &#123; // call times &#125; @Override public void surfaceDestroyed(SurfaceHolder holder) &#123; // call once // some recycle things doing here if(!mBmp.isRecycled())mBmp.recycle(); mRefresher = null; &#125; @Override public void surfaceRedrawNeeded(SurfaceHolder holder) &#123; // call times &#125; &#125; private void init() &#123; mSurfaceHolder = getHolder(); mSurfaceHolder.addCallback(callbackImp); &#125; //###########################################################################################// //####################################### Constructor #######################################// //###########################################################################################// public SurfaceViewDemo(Context context) &#123; super(context); init(); &#125; public SurfaceViewDemo(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public SurfaceViewDemo(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(); &#125; @RequiresApi(api = 21) public SurfaceViewDemo(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) &#123; super(context, attrs, defStyleAttr, defStyleRes); &#125;&#125; 游戏设计-微信飞机大战先看运行效果图: 飞行器基类作为一个 打飞机 游戏，我们所涉及到的对象会是 玩家飞机，敌机，Boss，Buff，子弹 等等，而这些东西是抽象在 二维平面 上移动的。在二维平面上移动，那就有坐标，但是又不是点移动，所以移动目标的 宽度，高度，中心点 什么的也就有必要了… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * Created by HCol on 2017/3/3. */abstract class FlyMount &#123; float x; float y; float width; float height; float speed; float centerX; float centerY; boolean isAlive; Paint mPaint = new Paint(Paint.ANTI_ALIAS_FLAG); Bitmap mMountBackground; FlyMount(Context ctx, @DrawableRes int imgRes) &#123; mMountBackground = BitmapFactory.decodeResource(ctx.getResources(), imgRes); width = mMountBackground.getWidth(); height = mMountBackground.getHeight(); isAlive = true; &#125; public abstract void init(float startX, float startY, float speedRate); public abstract void drawSelf(Canvas canvas); public abstract void move(float moveX, float moveY); public boolean isCollided(FlyMount obj) &#123; if (obj.x &gt;= x + width || obj.x + obj.width &lt;= x || obj.y &gt;= y + height || obj.y + obj.height &lt;= y) &#123; return false; &#125; else &#123; return true; &#125; //float aCX = centerX(this); //float aCY = centerY(this); //float bCX = centerX(target); //float bCY = centerY(target); // //return Math.abs(bCX - aCX) &lt;= (this.width + target.width) / 2 // &amp;&amp; Math.abs(bCY - aCY) &lt;= (this.height + target.height) / 2; &#125; public float centerX(FlyMount flyMount) &#123; return flyMount.x + flyMount.width / 2; &#125; public float centerY(FlyMount flyMount) &#123; return flyMount.y + flyMount.height / 2; &#125; protected void recycle() &#123; if (null != mMountBackground &amp;&amp; !mMountBackground.isRecycled()) &#123; mMountBackground.recycle(); &#125; &#125;&#125; 统一描述这些对象的抽象属性和抽象行为，便于管理和开发，所以我们需要这个抽象基类。 运动轨迹射击碰撞检测操作音效参考 大G 游戏编程》第一部 基础篇 SurfaceView 基础用法]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[个人 blog 搭建介绍]]></title>
      <url>%2F2017%2F02%2F01%2Fbuild-own-blog%2F</url>
      <content type="text"><![CDATA[前言 或许你心血来潮想要创建一个属于自己的 blog 或许创建 blog 的想法由来已久，只是迟迟没有付出实践 或许你只是无意间浏览到了这篇文章 那么你可以选择继续阅读这篇日志，全文大概需要10分钟，阅读并实现各个部分的话，你将获得： 一个属于自己的网络博客 以及搭建这个 blog 的周边知识和工具，当然，这些都是 免费 的软件和服务。 准备工具在开始之前，请完成以下步骤： 如果没有 github 账号，请注册一个。传送门 下载并安装 NodeJS。传送门 安装 Hexo 及相关插件。 1&gt; npm install -g hexo 安装完毕之后通过如下命令进行版本检测： 1&gt; hexo --version 相关配置。 搭建首先，我们在本地存储上找一个自己喜欢的目录下创建一个 blog 文件夹，打开命令行程序进入到当前目录 Windows：Shift+右键 –&gt; 在此处打开命令窗口 在这里，我们来熟悉几个 hexo 命令 12345678&gt; hexo init # 初始化静态站点&gt; hexo clean # 清除当前站点配置(模板文件，数据库...)&gt; hexo generate # 也可以简写成 hexo g ,根据配置生成 hexo 网页数据&gt; hexo server # 启动服务，在浏览器中输入 http://localhost:4000 查看效果&gt; hexo deploy # 也可以简写成 hexo d ,部署命令&gt; hexo new page &quot;PAGE_NAME&quot; # 创建新的页面&gt; hexo new &quot;POST_NAME&quot; # 创建新的日志 好，我相信到这里你已经兴致勃勃的想要创建一个自己的站点来看看了。那就来试试吧！ 12345678&gt; hexo init...&gt; hexo generate...&gt; hexo server... 然后我们打开浏览器，输入 http://localhost:4000 如下图所示 到这里，其实我们已经完成了大部分工作了，剩下的就是一些第三方插件的配置，如我所熟悉，常用的有： 搜索 字数统计 评论 … 这些功能可以参考：第三方服务集成，在这儿就不过多阐述了，有什么不清楚的或者困难，欢迎给我留言。 关于 MarkdownMarkdown 是 hexo 默认的标记语言，它因为简洁，使用方便被广泛用来日志记录。 关于部署前文提到的 github 我相信你已经注册了吧，为什么要注册它呢？如果你想让世界各地的因特网用户看到你写的日志，就需要放在公网上。 传统的方法是买空间，买域名，搭服务器，再部署，这样很麻烦而且费用也不少。而前面我提到这一切都是免费的，所以，我们用 git page 的形式来进行公网发布，简单粗暴。:) 登陆 github 创建一个 repository 进入 repository 的 settings 选择生成 gitpage git init 我们刚才创建的 hexo 项目 修改 hexo 的配置文件，将 hexo 和 git 关联起来关于这点，需要特别说明一下，hexo 和 git 关联起来的话需要进行一个 SSH 配置，这样就不用在每次自动部署的时候进行身份验证，一键命令搞定就行，之后如果看官喜欢折腾的话可以考虑自动持续构建（CI），只用 post 就行了，之后的 clean ，g ，d 等命令就让自动构建来帮你完成就好了。 扯多了，附上一篇介绍比较详细的参考文章：如何搭建一个独立博客——简明Github Pages与Hexo教程，参考里面的 配置SSH keys 这个章节就好了。 完成上面的步骤之后，我们通过如下命令就可以一键部署到 github 上了。 1&gt; hexo d 关于使用图片教程请参考 Markdown 无痛使用本地图片 下载安装完插件之后，在 blog 的 _post 目录下创建一个和文章命一模一样的文件夹，然后放入图片即可。 引用方式 1![image_alt_txt](POST_NAME_DIR/image.png) 参考 标准 Markdown 语法 Hexo + gitpage 搭建个人博客 NexT]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[FastJSON(1.1.52.android)解析Json字符串的一个坑]]></title>
      <url>%2F2016%2F07%2F21%2Ffastjson-tips%2F</url>
      <content type="text"><![CDATA[背景最近在捣鼓一个应用，用到了 JSON 串格式如下：其中，有一个字段: _id ,按照以往的经验，解析这个串，对应的 JavaBean 格式如下：1234567891011121314public class Bean&#123; private String _id; private String createdAt; private String desc; private String source; private String type; private String url; private boolean used; private String who; private String publishedAt; public void setXXX()&#123;...&#125; public T getXXX&#123;...&#125;&#125; 好的，看似没什么问题，解析也不报错，但是 debug 的时候发现，_id 字段没有数据，其他的都好好的，why？ 问题在哪？花了点时间追进去看发现，原来并不是我们的 JavaBean 格式有问题，是 FastJson 解析的时候，帮我们做了一些“不必要”的操作。在 FastJson 源码中的 JavaBeanInfo.class，这个类的 434 行，他帮我们把 “_” 给去掉了裁剪掉了(心好累…导致的问题就是在匹配网络数据中获取的 JSON 串时，无法命中 “_id” 字段，因为此时我们本地的 Bean 文件反射出来的 field 从 “_id” –&gt; “id”， 从而无法正确的获取到 “_id” 字段的值了… 为什么要这么做？从变量名你大概就能看出他获取字段属性的方式了,是从 class 的 method 中，裁剪 set 方法来获取这个 propertyName 接着会跟整个 Bean 文件中声明的字段进行比较，来确保每个字段跟 setXXX 能匹配上。假如匹配不上你不可能乱 set 值吧，对吧，不然打不死你… 解决办法既然他要裁一个，那咱们就加一个好喽，让本地的属性能匹配到网络数据中的 “_id” ，like this:1234567891011121314public class Bean&#123; private String __id; private String createdAt; private String desc; private String source; private String type; private String url; private boolean used; private String who; private String publishedAt; public void setXXX()&#123;...&#125; public T getXXX&#123;...&#125;&#125; 结语最后就能得到数据了： 一些疑问Q：为什么不直接用 Bean 文件的 field 字段来进行 JSON 串的匹配？A：因为 Bean 文件里没有 set 方法时，然后你的 field 又是 private 的时候你怎么处理呢？]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Failed to start genymotion]]></title>
      <url>%2F2016%2F07%2F02%2Ffailed-to-start-genymotion%2F</url>
      <content type="text"><![CDATA[吐槽自从升级Win10之后，genymotion老出现一些诡异的兼容问题，所以就于年前弃用掉了，选择了天天模拟器。 天天模拟器很强大，但是，他的系统版本无法满足我的要求，所以就准备回来捣鼓genymotion。 果然…玛德…它还是…那么…的…恶心… 说说我遇见的问题吧： 无法启动 genymotio,让我去看看 Virtual Box 出现什么问题了 到 Virtral Box 一看，发现麻痹是因为无法初始化虚拟网络，GG 好吧..既然你都告诉我无法创建虚拟网络了，那就创建呗… 为什么无法创建？ 有可能是以为权限问题？所以就给了它管理员权限运行，卒. 我又尝试了，重新创建一个网络适配器，卒. 好吧，方向好像不对，那就问百度，谷歌吧..麻痹，百度出来的什么鬼，bullshit…可能是我的关键字不对吧。把 Virtual Box 里的错误提取关键字放到大百度里，终于！BOOM！ Failed to open/create the internal network Vagrant on Windows10 遇到的问题 解决办法 Open Windows Network Connections Right click on VirtualBox Host only adapter that created Choose properties Check “VirtualBox NDIS6 Bridged Networking driver” disable and Enable the adapter]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Ubuntu16_04 Android环境搭建记录]]></title>
      <url>%2F2016%2F06%2F04%2Fubuntu-android%2F</url>
      <content type="text"><![CDATA[这篇文章记录了什么？ 中文输入法的配置 JDK 环境变量 Android Studio 配置 准备工具 Ubuntu 16.04 Sougou IME Java SDK 1.8.0_92 Android Studio IDE Android SDK Tools 以上工具具体版本以自己电脑系统版本为准，挑选合适的版本进行下载，我选择的是 X64 for Linux. 正文中文输入法的配置安装好搜狗输入法之后，需要去 fcitx configuration 中将输入法添加进 keyboard 中，而一直没找到 Sougou Pinyin的原因是因为下图： 找到Sougou Pinyin，选择 OK 即可配置完成，在输入的时候使用 SHIFT 可以进行输入法的切换. JDK 环境变量去 Oracle 上下载你想使用的 JDK 版本，你也可以选择使用 OpenJDK ，当然，笔者用的是 Oracle 的 JDK，下载完成，解压出来之后，将 JDK 文件放置到你熟悉的目录下，建议放在：/usr/lib/vm/java/ 接下来进行环境变量的配置，打开 /etc/profile 文件，在末尾进行如下设定：1234#set jdk environment export JAVA_HOME=/usr/lib/jvm/jdk1.7.0_21 export CLASSPATH=$CLASSPATH:.:$JAVA_HOME/lib:$JAVA_HOME/jre/lib export PATH=$JAVA_HOME/bin:$JAVA_HOME/jre/bin:$PATH 设定完成之后 java -version 看看是否配置成功，如果没有，请自行 Google 之. 这里有个坑，如果你执行 java -version 时提示1Error occurred during initialization of VM java/lang/NoClassDefFoundError: java/lang/Object 这是因为 JDK 的 lib/tools.pack 和 jre/lib/rt.pack 文件还没有被解压, 使用 JDK bin/unpack200 进行解压即可12$ unpack200 tools.pack tools.jar$ unpack200 rt.pcak rt.jar 再试试 java -version, 应该就可以显示出 Java 的版本信息来了吧.PS.建议把 lib/.pack和jre/lib/.pack 文件都解压了吧，在配置Android Studio的时候还会用到里面的jsse.pack 文件 Android Studio 配置在配置好 JDK 环境之后，进行 Andorid 开发换进行的搭建，准备好 Android Studio IDE 和 Android SDK tools 这两个工具，选择你熟悉的目录： 首先，你需要更新好你的 Android SDK，移步到 Android SDK 的 tools 目录下，执行 android shell1$ ./android 下载好相关的 build-tools, platforms, extras, platforms-tools… 移步到 Android Studio 目录下的 bin 文件中， 执行 studio shell1$ sudo sh studio.sh 这里有个坑，当你执行上面那个语句的时候, 可能会提示你 SHA-1 校检失败，去 JDK/jre/lib 目录下把 jsse.pack 解压了即可 然后 run 起来 Android Studio 的 IDE 了之后，去 settings 里面配置 Android SDK，如果提示1Unable to run mksdcard SDK tool 那是因为你的系统环境里缺少了一下lib的依赖1sudo apt-get install lib32z1 lib32ncurses5 lib32stdc++6 安装完了之后，再配置 Android SDK 即可，然后整个 Android 开发环境就搭建好了，如果想方便的使用 adb， ddms， android 等 SDK tools，需要再去 /etc/profile 里去进行环境变量的配置，和配置 JDK 的环境变量相似123# android environmentexport ANDROID_HOME=/your sdk root dir/export PATH=$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools:$PATH 祝君好运 BTW.其实我用 Ubuntu 的本意貌似是想用 g++ 的, 怎么莫名其妙的配置上了 Android 的开发环境了, shit…]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Win8 右键N卡插件吃内存]]></title>
      <url>%2F2016%2F05%2F22%2Fwin8-refresh-costs-memory%2F</url>
      <content type="text"><![CDATA[刚撸完，准备弄弄毕设，然后发现8G的内存莫名其妙就被占用了50%多！而且并没有开什么能吃内存的软件。。随后打开资源管理器一看，发现了那个孽障PS.图是网上找的，我的当时吃到了1个多G，简直惊呆了！！随后在网上找解决方案，其中一个的触发条件比较符合我的情况：在桌面空白处点击鼠标右键，这个进程就会吃一次内存，每次吃10多M，点一次，吃一次，点一次，吃一次….对于我这种长期闲的蛋疼要“刷新”的人来说，这个bug简直是梦魇啊 具体情况就是如上所述，下面贴上解决方案：首先你得确认你的情况和我所遭遇的差不多。接着，打开注册表找到directory目录，这里面中的shellex中的ContextMenuHandlers就是右键菜单中的上下文菜单栏具体是干什么的我还没详细研究过，应该是根据鼠标当前目标反馈左右键的MenuHandlers 对了！这里需要注意的是，我的是 这个程序生成的右键菜单导致的内存泄露，而N卡的话在ui里面的选项中就可以禁用掉右键上下文菜单。当你打开这个目录的时候，虽然你不知道该删除什么，你只需要找出可疑的对象，进行测试即可。 这就是我删除的注册表信息，在测试删除中记得先导出注册表，避免删错，方便恢复。 如果你按照这么做了，但是还是点击右键照成内存泄露的话，送个大招给你，重装系统！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[react-native 入门资源]]></title>
      <url>%2F2016%2F02%2F21%2Freact-native-hub%2F</url>
      <content type="text"><![CDATA[了解react-native React Native enables you to build world-class application experiences on native platforms using a consistent developer experience based on JavaScript and React. 套用官方的一句话：React Native 让你具备使用JavaScript和React一致的开发经验来构建拥有原生应用体验的世界级应用。 如果你也和我一样没弄清楚原生应用和非原生应用的区别的话，请参考戳我。 学习之前请参考一篇比较友好的react-native学习指南 开发环境配置网上有很多优秀的入门文章，在这我就不多做阐述了，把我觉得好的资源贡献给大家. 官方的start文章 React Native for Android入门老虎(一些优雅的爬坑姿势 =.=) 一篇简单明了的demo文章 Google大法好熟悉react-native 好，我默认你已经配置好react-native（RN）的开发环境并且已经init一个工程且顺利运行至welcome页面了，或者你已经跟着上面给出的demo文章进行过练习了。 那么接下来，我们就要开始搭建自己的react app了 :) 停停停！！你说什么，你现在什么鬼都还不知道？你不是都运行起Hello World（Dictionary）了么？还是不了解啊，好好好，再喂你点次的： React Doc-在学习React Native之前最好先学习一下React，着重了解下组件的生命周期。 Getting started with React 关于布局(StyleSheet) &amp;&amp; Flex布局教程_阮一峰 天啦噜，这么多，看完蛋都碎了，如果你是天才那估计现在已经可以上手敲Demo了，如果还不是的话也别死磕概念了，咱们一边动手一边学吧： RN版的知乎日报@race604 react-native官方的example 一个用react-native做的组件库 Google大法好 一个多星期的学习下来，发现React很好很强大啊，有想独立完成一个产品的心的同学熟悉了React以后应该能大大的提高生产效率，互联网上辣么多资料大多数没有精读官方文档来得实在，希望这份小小的合集能帮助到看官快速的学习React的知识 :)。 最后附上一些相关的refs: react-native-lession React Native Animated动画详解(大腾讯全端队伍AlloyTeam的文章，里面还有些干货)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[DrawerLayout、CoordinatorLayout、CollapsingToolbarLayout的使用--AndroidSupportDesign练手]]></title>
      <url>%2F2015%2F08%2F29%2Fandroid5-0-support-practice%2F</url>
      <content type="text"><![CDATA[先po一张效果图 PS：原谅题主的懒惰吧.. 看着是不是很酷炫，那是因为5.0的动画做得好，代码其实没有多少，搞清楚这个布局的层次关系很重要。 废话不多说了，先来看布局文件 最外层是一个DrawerLayout，它里面可以嵌套(一个?)container和多个drawer 在这个demo中DrawerLayout包含了一个CoordinatorLayout ， ListView ， NavigationView CoordinatorLayout 作为 container的根布局 listView和navigationview作为DarwerLayout中的darwer 在container中用CoordinatorLayout目的是为了我们在滑动recyclerview时，让顶部的appbarlayout中的组件产生响应 appbarlayout中的CollapsingToolbarLayout是用来控制toolbar和banner图片的响应效果 特别注意：为了使得Toolbar可以滑动，我们必须还得有个条件，就是CoordinatorLayout布局下包裹一个可以滑动的布局，比如 RecyclerView，NestedScrollView(经过测试，ListView，ScrollView不支持)具有滑动效果的组件。 下面的就是drawerLayout的使用注意事项了： 按情理来说，一个drawerLayout添加一个drawer就够了，可是脑洞一开，想着多加一个会怎样，尝试之后发现很好玩，以后可以各种乱入drawer了，哈哈哈。 因为做毕设的时候用的DrawerLayout还不是这样方便的，那会使用这个布局，设置起来麻烦很多，而现在的实现这个布局，布局文件设置好之后，只用三句话就搞定了，简单的可怕。 下面贴上源码，各位看官就自行分析吧： 主布局文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.v4.widget.DrawerLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:id="@+id/drawer_layout" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;android.support.design.widget.CoordinatorLayout android:id="@+id/main_content" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;android.support.design.widget.AppBarLayout android:id="@+id/app_bar_layout" android:layout_width="match_parent" android:layout_height="wrap_content" android:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar"&gt; &lt;android.support.design.widget.CollapsingToolbarLayout android:id="@+id/collapsing_toolbar_layout" android:layout_width="match_parent" android:layout_height="match_parent" app:contentScrim="@android:color/transparent" app:layout_scrollFlags="scroll|exitUntilCollapsed"&gt; &lt;ImageView android:id="@+id/banner" android:layout_width="match_parent" android:layout_height="match_parent" android:contentDescription="banner" android:scaleType="fitXY" android:src="@mipmap/banner" app:layout_collapseMode="parallax" app:layout_collapseParallaxMultiplier="0.5" /&gt; &lt;android.support.v7.widget.Toolbar android:id="@+id/tool_bar" android:layout_width="match_parent" android:layout_height="?attr/actionBarSize" android:background="@android:color/transparent" app:layout_collapseMode="pin" /&gt; &lt;/android.support.design.widget.CollapsingToolbarLayout&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.v7.widget.RecyclerView android:id="@+id/recycler_view" android:layout_width="match_parent" android:layout_height="wrap_content" app:layout_behavior="@string/appbar_scrolling_view_behavior" /&gt; &lt;android.support.design.widget.FloatingActionButton android:id="@+id/fab" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_margin="@dimen/activity_vertical_margin" android:src="@mipmap/ic_action_web_site" app:borderWidth="0dp" app:elevation="@dimen/fab_elevation" app:layout_anchor="@id/app_bar_layout" app:layout_anchorGravity="end|bottom" app:layout_collapseMode="parallax" app:layout_collapseParallaxMultiplier="0.7" app:pressedTranslationZ="@dimen/fab_translation_z_pressed" app:rippleColor="?attr/colorPrimary" /&gt; &lt;/android.support.design.widget.CoordinatorLayout&gt; &lt;ListView android:id="@+id/id_lv_left_menu" android:layout_width="match_parent" android:layout_height="match_parent" android:layout_gravity="end" android:paddingTop="0dp" android:background="#ffffffff" android:clipToPadding="false" android:divider="@null" android:listSelector="?attr/selectableItemBackground" /&gt; &lt;!--&lt;include--&gt; &lt;!--android:layout_width="match_parent"--&gt; &lt;!--android:layout_height="match_parent"--&gt; &lt;!--android:layout_gravity="start"--&gt; &lt;!--android:paddingTop="0dp"--&gt; &lt;!--android:background="#ffffffff"--&gt; &lt;!--android:clipToPadding="false"--&gt; &lt;!--android:id="@+id/custom_drawer"--&gt; &lt;!--layout="@layout/layout_listview_drawer" /&gt;--&gt; &lt;android.support.design.widget.NavigationView android:id="@+id/navigation_view" android:layout_width="wrap_content" android:layout_height="match_parent" android:layout_gravity="start" app:headerLayout="@layout/drawer_header" app:menu="@menu/menu_navigation_items" /&gt;&lt;/android.support.v4.widget.DrawerLayout&gt; Activity文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224package com.anhry.hcol.support.design.activity;import android.os.Bundle;import android.support.design.widget.AppBarLayout;import android.support.design.widget.CollapsingToolbarLayout;import android.support.design.widget.CoordinatorLayout;import android.support.design.widget.FloatingActionButton;import android.support.design.widget.NavigationView;import android.support.design.widget.Snackbar;import android.support.v4.view.GravityCompat;import android.support.v4.widget.DrawerLayout;import android.support.v7.app.AppCompatActivity;import android.support.v7.widget.LinearLayoutManager;import android.support.v7.widget.RecyclerView;import android.support.v7.widget.Toolbar;import android.view.Gravity;import android.view.LayoutInflater;import android.view.MenuItem;import android.view.View;import android.widget.AdapterView;import android.widget.ImageButton;import android.widget.ImageView;import android.widget.ListView;import com.anhry.hcol.support.design.adapter.LeftMenuListAdapter;import com.anhry.hcol.support.design.adapter.MenuItemAdapter;import com.anhry.hcol.support.design.module.LvMenuItem;import com.yanbober.support_library_demo.R;import com.yanbober.support_library_demo.RecyclerViewAdapter;import java.util.ArrayList;import java.util.Arrays;import java.util.List;/** * @author HCol * @email 282386589@qq.com * @create 2015/8/25 * @modify 2015年8月29日17:29:04 */public class DesignDemoActivity extends AppCompatActivity &#123; /** * views */ private DrawerLayout mDrawerLayout; private CoordinatorLayout mCoordinatorLayout; private AppBarLayout mAppBarLayout; private CollapsingToolbarLayout mCollapsingToolbarLayout; private ImageView mImageView; private Toolbar mToolbar; private RecyclerView mRecyclerView; private NavigationView mNavigationView; private FloatingActionButton mFloatingActionButton; private ImageView mRightNavigationBtn; private CoordinatorLayout mCustomDrawer; private RecyclerView leftMenuList; private ListView mLvLeftMenu; /** * members */ private RecyclerViewAdapter mAdapter; private LinearLayoutManager mRecyclerLayoutManager; private LeftMenuListAdapter mLeftMenuListAdapter; private List&lt;LvMenuItem&gt; dataSource; private static final String BTN_RIGHT_MENU_TAG = "tag"; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); initViews(); &#125; /** * init views */ private void initViews() &#123; setContentView(R.layout.activity_my_design); /* 抽屉形式界面的的两个布局控件 * * DrawerLayout 做根布局使用 * 因为要显示的内容界面和抽屉视图（NavigationView）是包含在此layout之下的 * * NavigationView 抽屉布局中的抽屉视图，有源码分析他的实现其实就是一个ListView * 而这里用的是原生的组件，所以在Menu目录下配置好要显示的条目，引用即可，非常方便. * * ref:http://blog.csdn.net/lmj623565791/article/details/46405409 * * */// 原生DrawerLayout mDrawerLayout = (DrawerLayout) findViewById(R.id.drawer_layout);// 利用ListView仿制的Drawer mLvLeftMenu = (ListView) findViewById(R.id.id_lv_left_menu); setUpDrawer();// 不用在意这一块// mCustomDrawer = (CoordinatorLayout) findViewById(R.id.custom_drawer);// leftMenuList = (RecyclerView) findViewById(R.id.rv_left_menu);// dataSource = new ArrayList&lt;&gt;(// Arrays.asList(// new LvMenuItem(R.mipmap.ic_action_web_site, "Home"),// new LvMenuItem(R.mipmap.ic_action_web_site, "Messages"),// new LvMenuItem(R.mipmap.ic_action_web_site, "Friends"),// new LvMenuItem(R.mipmap.ic_action_web_site, "Discussion"),// new LvMenuItem(R.mipmap.ic_action_web_site, "Discussion"),// new LvMenuItem(R.mipmap.ic_action_web_site, "Discussion"),// new LvMenuItem(R.mipmap.ic_action_web_site, "Discussion"),// new LvMenuItem(R.mipmap.ic_action_web_site, "Discussion"),// new LvMenuItem(),// new LvMenuItem("Sub Items"),// new LvMenuItem(R.mipmap.ic_action_web_site, "Sub Item 1"),// new LvMenuItem(R.mipmap.ic_action_web_site, "Sub Item 2")// ));// mLeftMenuListAdapter = new LeftMenuListAdapter(this, dataSource);// mRecyclerLayoutManager = new LinearLayoutManager(this);// leftMenuList.setAdapter(mLeftMenuListAdapter);// leftMenuList.setLayoutManager(mRecyclerLayoutManager); mNavigationView = (NavigationView) findViewById(R.id.navigation_view); mNavigationView.setNavigationItemSelectedListener(new NavigationView.OnNavigationItemSelectedListener() &#123; @Override public boolean onNavigationItemSelected(MenuItem menuItem) &#123; mDrawerLayout.closeDrawers(); return true; &#125; &#125;); /* 下面就是抽屉布局中[内容布局]的重点了 * * CoordinatorLayout 协调者布局 * AppBarLayout 导航栏布局 * CollapsingToolbarLayout ToolBar的可坍塌布局 * * 首先，这三个布局有什么用呢？ * * CoordinatorLayout * 官方文档介绍说是一个增强版的FrameLayout * 有两种主要的用途： * 1. 作为一个顶层布局文件来使用 * 2. 作为一个有[多个互动视图]的容器 * 就是当某一视图有特殊行为动作时，其他子视图会进行相应的动作反应。INTERACTION * * AppBarLayout * 一个模块化的布局文件，可以用来装载一切属于AppBar的组件 * * CollapsingToolbarLayout * * CollapsingToolbarLayout is a wrapper for Toolbar which implements a collapsing app bar. * It is designed to be used as a direct child of a AppBarLayout. * * 官方说，它的诞生主要是用来为toolbar锦上添花用的 * 被设计来作为AppBarLayout的亲儿子来使用 * * */ mCoordinatorLayout = (CoordinatorLayout) findViewById(R.id.main_content); mAppBarLayout = (AppBarLayout) findViewById(R.id.app_bar_layout); mCollapsingToolbarLayout = (CollapsingToolbarLayout) findViewById(R.id.collapsing_toolbar_layout); mImageView = (ImageView) findViewById(R.id.banner); mToolbar = (Toolbar) findViewById(R.id.tool_bar); // 创建右边导航按钮 ensureRightButtonView(); mToolbar.setNavigationIcon(R.mipmap.ic_drawer); mToolbar.addView(mRightNavigationBtn); mToolbar.setNavigationOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; mDrawerLayout.openDrawer(GravityCompat.START); &#125; &#125;); mCollapsingToolbarLayout.setTitle("CollapsingTitle"); /* init RecyclerView */ mRecyclerView = (RecyclerView) findViewById(R.id.recycler_view); mAdapter = new RecyclerViewAdapter(this); mRecyclerView.setAdapter(mAdapter); mRecyclerLayoutManager = new LinearLayoutManager(this); mRecyclerView.setLayoutManager(mRecyclerLayoutManager); mFloatingActionButton = (FloatingActionButton)findViewById(R.id.fab); mFloatingActionButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Snackbar.make(mRecyclerView , "papa i'm here" , Snackbar.LENGTH_LONG).show(); &#125; &#125;); &#125; private void setUpDrawer() &#123; LayoutInflater inflater = LayoutInflater.from(this); mLvLeftMenu.addHeaderView(inflater.inflate(R.layout.drawer_header, mLvLeftMenu, false)); mLvLeftMenu.setAdapter(new MenuItemAdapter(this)); mLvLeftMenu.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123; @Override public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123; mDrawerLayout.closeDrawers(); &#125; &#125;); &#125; private void ensureRightButtonView() &#123; if (mRightNavigationBtn == null) &#123; mRightNavigationBtn = new ImageButton(this, null, android.support.v7.appcompat.R.attr.toolbarNavigationButtonStyle); final Toolbar.LayoutParams lp = generateDefaultLayoutParams(); lp.gravity = GravityCompat.END | (Gravity.TOP &amp; Gravity.VERTICAL_GRAVITY_MASK); mRightNavigationBtn.setImageResource(R.mipmap.ic_drawer); mRightNavigationBtn.setLayoutParams(lp); mRightNavigationBtn.setTag(BTN_RIGHT_MENU_TAG); mRightNavigationBtn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; mDrawerLayout.openDrawer(GravityCompat.END); &#125; &#125;); &#125; &#125; private Toolbar.LayoutParams generateDefaultLayoutParams() &#123; return new Toolbar.LayoutParams(Toolbar.LayoutParams.WRAP_CONTENT, Toolbar.LayoutParams.WRAP_CONTENT); &#125;&#125; drawer head： 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="wrap_content" android:background="#000000" android:gravity="center_horizontal" android:orientation="vertical" android:padding="13dp"&gt; &lt;ImageView android:layout_width="wrap_content" android:layout_height="wrap_content" android:src="@drawable/icon_people" /&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginTop="15dp" android:text="UserName" android:textColor="?attr/colorAccent" android:textSize="24sp" /&gt;&lt;/LinearLayout&gt; ListViewAdapter： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100public class MenuItemAdapter extends BaseAdapter &#123; private final int mIconSize; private LayoutInflater mInflater; private Context mContext; public MenuItemAdapter(Context context) &#123; mInflater = LayoutInflater.from(context); mContext = context; mIconSize = context.getResources().getDimensionPixelSize(R.dimen.abc_dialog_padding_material);//24dp &#125; private List&lt;LvMenuItem&gt; mItems = new ArrayList&lt;LvMenuItem&gt;( Arrays.asList( new LvMenuItem(R.mipmap.ic_action_web_site, "Home"), new LvMenuItem(R.mipmap.ic_action_web_site, "Messages"), new LvMenuItem(R.mipmap.ic_action_web_site, "Friends"), new LvMenuItem(R.mipmap.ic_action_web_site, "Discussion"), new LvMenuItem(), new LvMenuItem("Sub Items"), new LvMenuItem(R.mipmap.ic_action_web_site, "Sub Item 1"), new LvMenuItem(R.mipmap.ic_action_web_site, "Sub Item 2") )); @Override public int getCount() &#123; return mItems.size(); &#125; @Override public Object getItem(int position) &#123; return mItems.get(position); &#125; @Override public long getItemId(int position) &#123; return position; &#125; @Override public int getViewTypeCount() &#123; return 3; &#125; @Override public int getItemViewType(int position) &#123; return mItems.get(position).type; &#125; @Override public View getView(int position, View convertView, ViewGroup parent) &#123; LvMenuItem item = mItems.get(position); switch (item.type) &#123; case LvMenuItem.TYPE_NORMAL: if (convertView == null) &#123; convertView = mInflater.inflate(R.layout.design_drawer_item, parent, false); &#125; TextView itemView = (TextView) convertView; itemView.setText(item.name); Drawable icon = mContext.getResources().getDrawable(item.icon); setIconColor(icon); if (icon != null) &#123; icon.setBounds(0, 0, mIconSize, mIconSize); TextViewCompat.setCompoundDrawablesRelative(itemView, icon, null, null, null); &#125; break; case LvMenuItem.TYPE_NO_ICON: if (convertView == null) &#123; convertView = mInflater.inflate(R.layout.design_drawer_item_subheader, parent, false); &#125; TextView subHeader = (TextView) convertView; subHeader.setText(item.name); break; case LvMenuItem.TYPE_SEPARATOR: if (convertView == null) &#123; convertView = mInflater.inflate(R.layout.design_drawer_item_separator, parent, false); &#125; break; &#125; return convertView; &#125; public void setIconColor(Drawable icon) &#123; int textColorSecondary = android.R.attr.textColorSecondary; TypedValue value = new TypedValue(); if (!mContext.getTheme().resolveAttribute(textColorSecondary, value, true)) &#123; return; &#125; int baseColor = mContext.getResources().getColor(value.resourceId); icon.setColorFilter(baseColor, PorterDuff.Mode.MULTIPLY); &#125;&#125; Item： 123456789101112131415161718192021222324252627282930313233343536public class LvMenuItem &#123; public LvMenuItem(int icon, String name) &#123; this.icon = icon; this.name = name; if (icon == NO_ICON &amp;&amp; TextUtils.isEmpty(name)) &#123; type = TYPE_SEPARATOR; &#125; else if (icon == NO_ICON) &#123; type = TYPE_NO_ICON; &#125; else &#123; type = TYPE_NORMAL; &#125; if (type != TYPE_SEPARATOR &amp;&amp; TextUtils.isEmpty(name)) &#123; throw new IllegalArgumentException("you need set a name for a non-SEPARATOR item"); &#125; &#125; public LvMenuItem(String name) &#123; this(NO_ICON, name); &#125; public LvMenuItem() &#123; this(null); &#125; public static final int NO_ICON = 0; public static final int TYPE_NORMAL = 0; public static final int TYPE_NO_ICON = 1; public static final int TYPE_SEPARATOR = 2; public int type; public String name; public int icon;&#125; Item的资源文件： design_drawer_item_separator： 12345678910&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;View android:layout_width="match_parent" android:layout_height="1dp" android:background="?android:attr/listDivider"/&gt;&lt;/FrameLayout&gt; design_drawer_item_subheader: 12345678910&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;TextView xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="?attr/listPreferredItemHeightSmall" android:gravity="center_vertical|start" android:maxLines="1" android:paddingLeft="?attr/listPreferredItemPaddingLeft" android:paddingRight="?attr/listPreferredItemPaddingRight" android:textAppearance="?attr/textAppearanceListItem" android:textColor="?android:textColorSecondary"/&gt; design_drawer_item: 123456789101112&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;TextView xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="?attr/listPreferredItemHeightSmall" android:paddingLeft="?attr/listPreferredItemPaddingLeft" android:paddingRight="?attr/listPreferredItemPaddingRight" android:drawablePadding="32dp" android:gravity="center_vertical|start" android:maxLines="1" android:textAppearance="?attr/textAppearanceListItem" android:textColor="?android:attr/textColorPrimary"/&gt; 参考资料： http://www.2cto.com/kf/201506/409067.html http://www.open-open.com/lib/view/open1433385856119.html#_label8 http://blog.csdn.net/lmj623565791/article/details/46405409 PS：为什么放多个drawer，而drawerLayout打开drawer的时候不会混乱呢？ 没事就看看源码，反正又不要钱..]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[When Is Cheryl's Birthday]]></title>
      <url>%2F2015%2F04%2F28%2Fwhen-is-cheryls-birthday%2F</url>
      <content type="text"><![CDATA[大早上起来逛微博，看见@西瓜大丸子汤Po的一个逻辑题，遂点开看之… 原文链接：http://nbviewer.ipython.org/url/norvig.com/ipython/Cheryl.ipynb 然后发现这不是TM的猜卡牌的那个题么，某次面试的时候还跪了来着。。接着就魔性大发，试着用JAVA来学习一下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189package cn.edu.bipt.hcol;import java.util.ArrayList;import java.util.List;/** * This logic puzzle has been making the rounds: * * Albert and Bernard just became friends with Cheryl, and they want to know * when her birtxhday is. Cheryl gave them a list of 10 possible dates: * * May 15 May 16 May 19 June 17 June 18 July 14 July 16 August 14 August 15 * August 17 Cheryl then tells Albert and Bernard separately the month and the * day of the birthday respectively. * * Albert: I don't know when Cheryl's birthday is, but I know that Bernard does * not know too. * * Bernard: At first I don't know when Cheryl's birthday is, but I know now. * * Albert: Then I also know when Cheryl's birthday is. * * So when is Cheryl's birthday? * * @author Colin * */public class WhenIsCherylsBirthday &#123; public static final String DATES[] = &#123; "May 15", "May 16", "May 19", "June 17", "June 18", "July 14", "July 16", "August 14", "August 15", "August 17" &#125;; /** * Albert : I don't know when Cheryl's birthday is, but I know that Bernard * does not know too. * * That means: Albert : After Cheryl told me the month of her birthdate, I * didn't know her birthday, I don't know which day Cheryl told Bernard, but * I know that for all of the possible dates, if Bernard is told that day , * he wouldn't know the birthdate. * */ private boolean statement3(String date) &#123; // When Cheryl told the month to Albert // Albert : I know if Bernard doesn't knows Cheryl birthday when Cheryl // told him the day // that means the day is not unique in DATES // that means I know the month and I know the days but Bernard doesn't // konws boolean temper = true; List&lt;String&gt; possible_dates = tell(getMonth(date)); for (int i = 0; i &lt; possible_dates.size(); i++) &#123; if (know(tell(getDay(possible_dates.get(i))))) &#123; temper = false; break; &#125; &#125; return !know(possible_dates) &amp;&amp; temper; &#125; /** * Bernard: At first I don't know when Cheryl's birthday is, but I know now. * * Bernard: At first time Cheryl told me the day,and i didn't know. Then I * considered just the dates for which Albert's statement3 is true,and now I * know. * * @param date * @return */ private boolean statement4(String date) &#123; List&lt;String&gt; atFirst = tell(getDay(date)); List&lt;String&gt; filterItem = new ArrayList&lt;String&gt;(); for (String item : atFirst) &#123; if (statement3(item) == true) filterItem.add(item); &#125; return !know(atFirst) &amp;&amp; know(filterItem); &#125; /** * Albert: Then I also know when Cheryl's birthday is. * * @param date * @return */ private boolean statement5(String date) &#123; List&lt;String&gt; mList = tell(getMonth(date)); List&lt;String&gt; filterItem = new ArrayList&lt;String&gt;(); for (String item : mList) &#123; if (true == statement4(item)) filterItem.add(item); &#125; return know(filterItem); &#125; /** * filter(statement4 , filter(statement3 , DATES)) filter(statement4 , * tell(getMonth(date))) * * @param date * @return */ private boolean statement3to5(String date) &#123; return statement3(date) &amp;&amp; statement4(date) &amp;&amp; statement5(date); &#125; private String getCherylsBirthday(String dates[]) &#123; String birthday = ""; for (String date : dates) &#123; if (true == statement3to5(date)) birthday = date; &#125; return birthday; &#125; /** * Cheryl tells a part of birthday to someone; Return a new list of possible * dates that match the part. * * @param part * @param return */ private List&lt;String&gt; tell(String part) &#123; List&lt;String&gt; mList = new ArrayList&lt;String&gt;(); char c = part.charAt(0); // 匹配“月” if (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') &#123; for (String date : DATES) &#123; if (part.equals(getMonth(date))) &#123; mList.add(date); &#125; &#125; &#125; else &#123;// 匹配“日” for (String date : DATES) &#123; if (part.equals(getDay(date))) &#123; mList.add(date); &#125; &#125; &#125; return mList; &#125; /** * A person knows the birthday if they have exactly one possible date * * @return */ private boolean know(List&lt;String&gt; mList) &#123; return mList.size() == 1; &#125; /** * 获取data中的“月”的数据 * * @param data * getMonth("May 15") * @return May */ private String getMonth(String date) &#123; return date.split(" ")[0]; &#125; /** * 获取data中的“日”的数据 * * @param data * getMonth("May 15") * @return 15 */ private String getDay(String date) &#123; return date.split(" ")[1]; &#125; public static void main(String[] args) &#123; WhenIsCherylsBirthday whenIsCherylsBirthday = new WhenIsCherylsBirthday(); System.out.println(whenIsCherylsBirthday.getCherylsBirthday(DATES)); &#125;&#125; 顺着原文中的思路和Python代码修改的…话说Python还真是叼炸天啊…all()和filter()这俩函数简直叼…膜拜之… 疑惑：还是不太明白statement3的用处。。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[常用运算符]]></title>
      <url>%2F2015%2F04%2F11%2Foperator-note%2F</url>
      <content type="text"><![CDATA[Po上来，方便用到。。考前利器啊 123456789101112131415161718192021222324252627// &amp; 运算符优先级大于 |// 先运算4&amp;5得 101// 然后从左至右进行或运算1|10|11得11// 最后运算11和101的或运算得111int x = 1 | 2 | 3 | 4 &amp; 5;// 0x10 = 00010000 = 16// 0x 开始表示 16进制// 0 开始表示 8 进制// 1、00000011 取非 = 11111100 = -4// 2、与 5进行与运算 00000101 &amp; 11111100 = 00000100 = 4 符号位也参与运算// 3、 14 00001110// 16 00010000// 进行异或运算 00011110 = 30// 4、 30左移4位 = 111100000 = 0740 = 0x1e0 = 480short x_8 = 0740;short x_16 = 0x1e0;short x1 = (14 ^ 0x10) &lt;&lt; (5 &amp; ~3);// &gt;&gt; 和 &lt;&lt; 是带符号位的移位// &gt;&gt;&gt; 是无符号位的移位// -2 = 10000010 &lt;-- 这是原码 计算机中是用补码表示 即： 11111110// 右移 5 位得 1111111111110 后面的5位被舍弃得 11111111// 带符号位的位移运算，正数左侧补0，负数左侧补1// 2 &gt;&gt; 5 = 0// -2 &gt;&gt; 5 = -1int x2 = -2 &gt;&gt; 5;]]></content>
    </entry>

    
  
  
</search>
